# PR301-Assignment 3 Documentation

## Design Patterns

### Name: Builder

Location: PR301-Assignment-2-Version-1-fileHandler.py-PrintClass-between Line 0 and 107

Reasons this design pattern is suitable to be applied: 

1. PrintClass is doing more than one task. It is, building the individual components of the "result" on line 21, combining them into "result" in the output_class method, and then repeatedly calling the output_class method in the output_classes method to write them to files. Due to the Single Responsibility Principle of SOLID, therefore, this class should be modified such that the building of the individual components of "result" take place in a separate class from PrintClass, which should both be in a separate from the class which calls output_classes and writes the output to files. This is exactly what the builder design pattern does.

 2. The builder design pattern enforces the single responsibility principle by ensuring that the building of individual components of a product is handled by one class (the builder, which in my case would contain the methods required to build all the components of the "result" string, i.e. add_methods, add_attributes, add_relationships, add_class_names, etc); the steps needed to build it together is handled by another class (the director, which would contain a method to call add_class_names, add_attributes, add_relationships, etc in the correct order); and the code which calls the director (in this case, output_classes since that is identified as the client code) to execute the steps in which the builder builds the product is separate from the builder and director classes. In this way each class does only one task, thus satisfying the single responsibility principle from SOLID. Hence, the builder pattern is suitable to apply to the code specified. 

3. Applying the builder design pattern helps the code to become more extendable. Since, in the builder design pattern, there is an abstract class which defines all builder classes, and one of them will be used to create the Python code string which is the product in this case; this abstract class allows for more builder classes to be created, for example if JavaScript code was to be created as the final product instead of Python code, then another builder which would create JavaScript components would be made. The director remains independent of the way by which the builder builds the components since it only tells the builder the order in which to build the product, therefore, the program is now easily extendable and programmers may now add whatever extra builder classes they require, without having to worry about having to change director or the calls in the client code every single time. All they need to do is create a new builder to handle the new functionality required, and the rest is taken care of by the structure of the builder design pattern. Thus, applying the builder design pattern to this code allows it to be extended easily since all of the implementation to build specific outputs is contained within the builder class, which is one of the reasons why it is a suitable design pattern to apply to the code. Furthermore, applying the builder design pattern and thus making the code more extendable helps the code conform better to the Open-closed principle from SOLID, which states that software entities should be open for extension. 

4. Applying the builder design pattern to PrintClass makes it more flexible. If, for example, there was a builder class which built Python code as the final product string, and another builder class which built JavaScript code as the final product string, the client can then call either, thus giving more flexibility to the client, since they can call whichever one they require. In the original code, it is very rigid and inflexible since the client can only create a Python code string, so if they wanted to create a JavaScript code string or one of any other language, they couldn't, and this is inflexible. Therefore, applying the builder design pattern to PrintClass is suitable as it allows the code to be more flexible. 

### Name: Strategy

Location: PR301-Assignment-2-Version-1-chart_maker.py-ChartMaker-between Line 0 and 39

Reasons this design pattern is suitable to be applied: 

1. The single responsibility principle from SOLID states that each class must do only one thing, and that for the whole program responsibility has been separated and distributed so that each class has only one responsibility. ChartMaker class does three things; it creates a bar chart, creates a pie chart, and creates a line graph via the methods create_bar_chart, create_pie_chart, and create_line_graph respectively. Therefore, this violates the single responsibility principle. By applying the strategy design pattern, each of the methods create_bar_chart, create_pie_chart, and create_line_graph will be in their own strategy class, which means that each strategy class will execute only one task. For example, the BarChartMaker would be the class with a method to transform the input data into a bar chart, which retains the same functionality as the original Assignment 2 code, but satisfies the single responsibility principle since it does only one thing. Same with the PieChartMaker class and the LineGraphMaker classes which will be created when the strategy design pattern is applied to this code. Hence, the strategy pattern is a suitable design pattern to be applied to the code in ChartMaker since it allows it to satisfy the single responsibility principle from SOLID. Furthermore, since each class has its own responsibility, changing one would not require changing all the rest too, so the code is more flexible. For instance, changing the PieChartMaker would not require changing any of the other classes, making modifying and reusing the code more easy. Therefore, this design pattern is very suitable for applying to my code. 

2. It enables my program to be more extendable, for example, another strategy, maybe an Area chart, could be added if the client needs to without having to change any other code. This opens the program up to allow for extra functionality to be added when the client needs it. 

3. The program is more flexible, as the Client can choose what type of strategy they want. For example, in my program, they might want a bar chart. In this case they'd choose to instantiate the BarChartMaker and use it to decorate their data. Or, if they'd prefer representing their data via a pie chart, they'd instantiate the PieChartMaker. Applying the design pattern allows for this functionality to be added, making the program more open to modification and flexible to the client's needs. 

4. The design pattern allows the strategy to use one object and then add the type of chart the client requires without having to build many objects, making the program more Object-Oriented. Applying the strategy design pattern to my code allows for the manipulation of an object. The data, all_num doesn't change, but the client can change how it is presented by choosing the appropriate strategy to display it, for example, BarChartMaker to display all_num in the form of a bar chart. 


